[{"id":0,"href":"/docs/encryption/","title":"Encryption","section":"Docs","content":" Encryption # Each account balance is encrypted using ElGamal encryption over elliptic curves, which supports additive homomorphism. A user\u0026rsquo;s encrypted balance is represented as:\nEnc[y](b, r) = (g^b y^r, g^r)\nThis is the key property Tongo leverages on-chain to efficiently update balances while keeping them private.\nTo decipher their balance a user can recover g^b with their private key by computing L / R^x. This is only possible with the knowledge of the private key x. Then g^b has to be brute-forced to obtain b. If b lies in a small range, such as [0, 2^32), the brute force can be done without a problem.\n"},{"id":1,"href":"/docs/transfer/","title":"Transfer","section":"Docs","content":" Transfer # When a user y who has a balance b_0, wants to transfer an amount b \u0026lt; b_0 to another user »≥, they must create two encryptions:\n(L, R) = Enc[y](b, r) (»¥, ·πô) = Enc[»≥](b, r)\nThe transaction is done by subtracting the encryption (L, R) from the y balance and adding the encryption (»¥, ·πô) to the »≥ balance.\nThe sender has to prove that:\nKnowledge of x such that y = g^x (POE) Knowledge of r such that R = g^r (POE) L = g^b y^r (PED) »¥ = g^b »≥^r (PED) b ‚àà [0, b_max) (RAN) The balance after deduction b' = b_0 - b is positive (RAN) "},{"id":2,"href":"/docs/auditor/","title":"Viewing Key / Auditor","section":"Docs","content":" Auditability # Global Auditor # At the time of deploying the Tongo contract, the deploying entity must choose a public key that will serve as the global auditor key. For each user, the contract stores the account balance encrypted under the auditor‚Äôs public key. The auditor can decipher the amount stored for each account at any time.\nFor a transaction to be valid, the user must include (along with the new ciphered balance for their own key and the recipient‚Äôs key) a ciphered balance for the global auditor‚Äôs public key, along with a ZK proof showing that this ciphered balance encodes the same amount sent in the transaction.\nThe global auditor can:\nDecipher the balance of each account at any time. Decipher the amount sent in any transfer. The global auditor must:\nGenerate a secret key pair (sk, pk) and ensure that the secret key is not leaked. Provide the public key when the contract is deployed. Note: If the global auditor‚Äôs secret key is leaked, all balances and transactions could be compromised. It is the responsibility of the global auditor to store the key securely.\nAudit Ex Post # We have implemented a protocol that allows an entity to audit, if the user agrees, the balance or the amount sent in a transaction. The entity only has to request an audit of a specific transaction and provide a public key.\nThe user may send a ciphered balance for the auditor‚Äôs public key along with a ZK proof showing that the ciphered balance encodes the amount sent in the transaction being audited. This is done off-chain and does not require any additional on-chain infrastructure.\nThis could even be used in a scenario where user A is waiting for user B to transfer some amount to user C.\n"},{"id":3,"href":"/docs/zk-proofs/","title":"ZK Proofs","section":"Docs","content":" Tongo ZK Proofs # POE: Proof of Exponent # Prove knowledge of x such that y = g^x.\nPublic: g, y\nPrivate: x\nPick k ‚Üê ùîΩ_p\nCompute A = g^k\nVerifier sends challenge c\nProver computes s = k + c‚ãÖx\nVerifier checks: g^s = A ‚ãÖ y^c\nPED: Pedersen Commitments # Prove that V = g^b ‚ãÖ h^r\nPublic: g, h, V\nPrivate: b, r\nPick k_b, k_r ‚Üê ùîΩ_p\nCompute A = g^{k_b} ‚ãÖ h^{k_r}\nVerifier sends challenge c\nProver computes: s_b = k_b + c‚ãÖb s_r = k_r + c‚ãÖr\nVerifier checks: g^{s_b} h^{s_r} = A ‚ãÖ V^c\nProof of Range # Given V = g^b ‚ãÖ h^r, show that b ‚àà [0, 2^32)\nDecompose b into bits: b = ‚àë b_i ‚ãÖ 2^i\nCommit each bit: V_i = g^{b_i} ‚ãÖ h^{r_i}\nReconstruct: V = ‚àè V_i^{2^i}\nEach V_i must be either:\nV_i = h^{r_i} (if b_i = 0) V_i = g ‚ãÖ h^{r_i} (if b_i = 1) Prove each with a POE OR proof:\nœÄ_bit: V = h^r OR V/g = h^r\nUse Fiat-Shamir to make all interactive protocols non-interactive by replacing c with H(A)\n"}]